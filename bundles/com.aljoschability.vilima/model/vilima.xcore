@GenModel(nonNLSMarkers="true",
	complianceLevel="7.0",
	bundleManifest="false",
	suppressEMFModelTags="true",
	suppressUnsettable="true",
	updateClasspath="false",
	pluginKey="")
@Ecore(nsURI='http://www.aljoschability.com/vilima/2014')
package com.aljoschability.vilima

/* This represents a Matroska file and contains all information after the actual file has been read. */
class MkFile
{
	/* The path of the file. */
	String[1] path
	/* The file name. */
	String[1] name
	/* The size of the file in bytes. */
	Long[1] size
	/* The date/time of the file creation. */
	Long[1] dateCreated
	/* The date/time of the last file modification. */
	Long[1] dateModified
	/* The segment information of the Matroska container. */
	contains MkInformation[1] information
	/* The tracks contained in the Matroska container. */
	contains MkTrack[] tracks
	/* The attachment inside the Matroska container. */
	contains MkAttachment[] attachments opposite file
	/* The editions contained in the Matroska container. */
	contains MkEdition[] editions
	/* The tags contained in the Matroska container. */
	contains MkTag[] tags
}

/* This contains all the information about the segment of a Matroska container. */
class MkInformation
{
	/* Duration of the segment (based on TimecodeScale). */
	Double duration = "-1"
	/* Date of the origin of time-stamp (value 0), i.e. production date. */
	Long date
	/* A randomly generated unique ID to identify the current segment between many others (128 bits). */
	String uid
	/* A unique ID to identify the previous chained segment (128 bits). */
	String previousUid
	/* A unique ID to identify the next chained segment (128 bits). */
	String nextUid
	/* General name of the segment. */
	String title
	/* Muxing application or library ("libmatroska-0.4.3"). */
	String[1] muxingApp
	/* Writing application ("mkvmerge-0.3.3"). */
	String[1] writingApp
}

/* This represents a track of the Matroska container and describes the track with all elements. */
class MkTrack
{
	/* The track number as used in the Block Header (using more than 127 tracks is not encouraged, though the design allows an unlimited number). */
	Integer[1] number
	/* A unique ID to identify the Track. This should be kept the same when making a direct stream copy of the Track to another file. */
	Long[1] uid
	/* The type of the track. */
	MkTrackType[1] ^type = "UNKNOWN"
	/* Set if the track is usable. */
	Boolean[1] flagEnabled = "true"
	/* Set if that track (audio, video or subs) SHOULD be active if no language found matches the user preference. */
	Boolean[1] flagDefault = "true"
	/* Set if that track MUST be active during playback. There can be many forced track for a kind (audio, video or subs), the player should select the one which language matches the user preference or the default + forced track. Overlay MAY happen between a forced and non-forced track of the same kind. */
	Boolean[1] flagForced = "false"
	/* Set if the track may contain blocks using lacing. */
	Boolean[1] flagLacing = "true"
	/* A human-readable track name. */
	String name
	/* Specifies the language of the track in the Matroska languages form. */
	String language = "eng"
	/* An ID corresponding to the codec, see the codec page for more info. */
	String[1] codecId
	/* Private data only known to the codec. */
	String codecPrivate
	/* A human-readable string specifying the codec. */
	String codecName
	/* Set if the video is interlaced. */
	Boolean videoFlagInterlaced = "false"
	/* Width of the encoded video frames in pixels. */
	Integer videoPixelWidth
	/* Height of the encoded video frames in pixels. */
	Integer videoPixelHeight
	/* The number of video pixels to remove at the bottom of the image (for HDTV content). */
	Integer videoPixelCropBottom = "0"
	/* The number of video pixels to remove at the top of the image. */
	Integer videoPixelCropTop = "0"
	/* The number of video pixels to remove on the left of the image. */
	Integer videoPixelCropLeft = "0"
	/* The number of video pixels to remove on the right of the image. */
	Integer videoPixelCropRight = "0"
	/* Width of the video frames to display. The default value is only valid when DisplayUnit is 0. */
	Integer videoDisplayWidth
	/* Height of the video frames to display. The default value is only valid when DisplayUnit is 0. */
	Integer videoDisplayHeight
	/* How DisplayWidth & DisplayHeight should be interpreted (0: pixels, 1: centimeters, 2: inches, 3: Display Aspect Ratio). */
	Integer videoDisplayUnit = "0"
	/* Specify the possible modifications to the aspect ratio (0: free resizing, 1: keep aspect ratio, 2: fixed). */
	Integer videoAspectRatioType = "0"
	/* Sampling frequency in Hz. */
	Double audioSamplingFrequency = "8000.0"
	/* Real output sampling frequency in Hz (used for SBR techniques). */
	Double audioOutputSamplingFrequency
	/* Numbers of channels in the track. */
	Integer audioChannels = "1"
}

enum MkTrackType
{
	UNKNOWN
	VIDEO
	AUDIO
	COMPLEX
	LOGO
	SUBTITLE
	CONTROL
}

/* This represents a file attachment */
class MkAttachment
{
	/* The file the attachment is attached to. */
	container MkFile file opposite attachments
	/* The ID used in mkvextract, e.g. */
	Integer[1] ^id
	/* Unique ID representing the file, as random as possible. */
	Long[1] uid
	/* The size of the attached file. */
	Long[1] size
	/* Filename of the attached file. */
	String[1] name
	/* MIME type of the file. */
	String[1] mimeType
	/* A human-friendly name for the attached file. */
	String[1] description
}

/* Contains all information about a segment edition. */
class MkEdition
{
	/* A unique ID to identify the edition. It's useful for tagging an edition. */
	Long[1] uid = "0"
	/* If an edition is hidden (1), it should not be available to the user interface (but still to Control Tracks; see flag notes). */
	Boolean[1] flagHidden = "false"
	/* If a flag is set (1) the edition should be used as the default one. */
	Boolean[1] flagDefault = "false"
	/* Contains the chapters of the edition. */
	contains MkChapter[] chapters
}

/* Represents a chapter of an edition. */
class MkChapter
{
	/* A unique ID to identify the Chapter. */
	Long[1] uid = "0"
	/* Timestamp of the start of Chapter (not scaled). */
	Long[1] start = "-1"
	/* If a chapter is hidden (1), it should not be available to the user interface (but still to Control Tracks; see flag notes). */
	Boolean[1] flagHidden = "false"
	/* Specify wether the chapter is enabled. It can be enabled/disabled by a Control Track. When disabled, the movie should skip all the content between the TimeStart and TimeEnd of this chapter (see flag notes). */
	Boolean[1] flagEnabled = "true"
	/* Contains all possible strings to use for the chapter display. */
	contains MkChapterText[] texts
}

/* Represents a text for a chapter */
class MkChapterText
{
	/* Contains the string to use as the chapter atom. */
	String[1] text
	/* The languages corresponding to the string, in the bibliographic ISO-639-2 form. */
	String[] languages
}

/* Element containing elements specific to Tracks/Chapters. */
class MkTag
{
	/* A number to indicate the logical level of the target. */
	Integer target
	/* An informational string that can be used to display the logical level of the target. */
	String targetText
	/* The actual nodes that contains the tag data. */
	contains MkTagNode[] nodes
}

/* Represents a tag node holding actual information. */
class MkTagNode
{
	/* The name of the Tag that is going to be stored. */
	String[1] name
	/* The value of the Tag. */
	String value
	/* Specifies the language of the tag specified, in the Matroska languages form. */
	String[1] language = "und"
	/* 	Indication to know if this is the default/original language to use for the given tag. */
	Boolean[1] languageDefault = "true"
	/* This possibly contains further nested information. */
	contains MkTagNode[] nodes
}

//
// #############################################################################
// #############################################################################
//
/*  */
class VilimaColumnConfiguration
{
	String[1] sortColumnId
	contains VilimaColumn[] columns
}

class VilimaColumn
{
	String[1] ^id
	Integer[1] width
}

//
// #############################################################################
// #############################################################################
//
/* An identifier that which is used for example to connect a movie to the appropriate TVDB entry. */
class VilimaIdentifier {
	/* The unique name of the identifier */
	id String[1] ^name
	/* The value of the identifier */
	String[1] value
}

class VilimaLibrary
{
	contains VilimaMovie[] movies
	contains VilimaMovieCollection[] movieCollections
	contains VilimaShow[] shows
}

class VilimaMovieCollection
{
	String[1] title
	String[1] summary
	refers VilimaMovie[] movies opposite collection
}

class VilimaShow
{
}

//RECORDING_LOCATION
//PRODUCTION_STUDIO
//GENRE
//CONTENT_TYPE
//SUMMARY
//KEYWORDS
//DATE_RELEASED
class VilimaMovie
{
	String[1] title
	String tagline
	refers VilimaMovieCollection collection opposite movies
}

class ScrapeMovie
{
	contains VilimaIdentifier[] identifiers
	String[1] title
	String tagline
	String summary
	Integer runtime
	Integer voteCount
	Double votePercentage
	String releaseDate
	String posterUrl
}

/* === FUCK2 ========================== */
class XVilimaLibrary
{
	contains XVilimaContentType[] contentTypes
	contains XVilimaGenre[] genres
	contains MkFile[] files
}

class XVilimaContentType
{
	String[1] name
	refers MkFile[] files
}

class XVilimaGenre
{
	String[1] name
	refers MkFile[] files
}